module.exports = function(RED) {
  "use strict";
  var WS     = require("ws");
  var bciLib = require("./bci-lib");
  var config = require("./bci-config");

  function WebSocketInNode(n) {
    RED.nodes.createNode(this, n);

    var node               = this;
    var path               = config.path;
    var clientid           = config.clientid;
    var clientsecret       = config.clientsecret;
    var errorCode          = config.errorCode;
    var sessionID          = null;
    var auth               = null;
    var headsetID          = null;
    var loggedInOSUsername = "";
    var loggedInUsername   = "";

    function startconn() {
      // Connect to remote endpoint
      node.tout   = null;
      node.socket = new WS(path, { rejectUnauthorized: false });
      node.socket.setMaxListeners(config.maxSocketListener);
      node.context().global.set("socket", node.socket);
      handleConnection();
    }

    function handleConnection() {
      node.socket.on("open", function() {
        node.closing = false;
        bciLib.getUserLogin(node);

        node.status({
          fill : "white",
          shape: "ring",
          text : "Connecting ..."
        });
      });

      node.socket.on("close", function() {
        node.status({
          fill : "red",
          shape: "ring",
          text : 
            "Please ensure that you have Cortex installed and running in the background."
        });
        if (!node.closing) {
          clearTimeout(node.tout);
          node.tout = setTimeout(function() {
            startconn();
          }, 3000);
        }
      });

      node.socket.on("message", function(data) {
        var msg = JSON.parse(data)
        console.log("Message from Cortex: ");
        console.log(msg);

        var streamArr = node.context().global.get("streamArr") || [];
        if (!!msg.warning) {
          switch (msg.warning.code) {
            case 0: 
              // Stop session
              sessionID = null;
              setTimeout(() => {
                bciLib.queryHeadsets(node);
              }, 3500);
              break;

            case 1: 
              // Close session
              break;

            case 2: 
              // Already logged ininin
              bciLib.authorizeWithOutLicense(node, clientid, clientsecret);

              break;

            case 3: 
              // Log out
              node.status({
                fill : "red",
                shape: "ring",
                text : "Please login via Emotiv Apps"
              });
              break;              

            default: 
              // node.status({fill: 'red', shape: 'ring', text: msg.warning.message});
              break;
          }
        } else if (!!msg.id && !!msg.error) {
          switch (msg.error.code) {
            case errorCode.ERR_NO_HEADSET: 
              node.status({
                fill : "red",
                shape: "ring",
                text : "No headset is connected!"
              });
              headsetID = null;
              sessionID = null;
              setTimeout(() => {
                bciLib.queryHeadsets(node);
              }, 3500);
              break;

            case errorCode.ERR_SESSION_DOES_NOT_EXIST: 
              sessionID = null;

              setTimeout(() => {
                if (!node.closing) {
                  if (null == sessionID)
                    bciLib.createSession(node, auth, headsetID);
                }
              }, 5000);

              break;

            case errorCode.ERR_SESSION_CONFLICT: 
              throw new Error("ERR_SESSION_CONFLICT");

            case errorCode.ERR_REQUEST_TIME_OUT: 
              node.status({
                fill : "red",
                shape: "ring",
                text : "Request time out, please re-deploy flow!"
              });
              break;

            case errorCode.ERR_INVALID_PROFILE: 
              node.status({
                fill : "red",
                shape: "ring",
                text : "Request time out, please re-deploy flow!"
              });

            default: 
              // node.status({fill: 'red', shape: 'ring', text: msg.error.message});
              break;
          }
        } else {
          switch (msg.id) {
            case "getUserLogin": 
              if (msg.result.length != 0) {
                loggedInUsername   = msg.result[0].username;
                loggedInOSUsername = msg.result[0].loggedInOSUsername;
                bciLib.hasAccessRight(node, clientid, clientsecret);
              } else {
                node.status({
                  fill : "red",
                  shape: "ring",
                  text : "Please login via other Emotiv Cortex Apps"
                });
              }
              break;

            case "hasAccessRight": 
              if (msg.result.accessGranted) {
                bciLib.authorizeWithOutLicense(node, clientid, clientsecret);
              } else {
                setTimeout(() => {
                  bciLib.requestAccess(node, clientid, clientsecret);
                }, 3000);
              }
              break;

            case "requestAccess": 
              bciLib.hasAccessRight(node, clientid, clientsecret);
              break;

            case "login": 
              node.status({ fill: "green", shape: "ring", text: "Logged in" });
              bciLib.authorizeWithOutLicense(node, clientid, clientsecret);
              break;

            case "authorizeWithOutLicense": 
              sessionID = null;
              node.status({ fill: "green", shape: "ring", text: "Authorized" });
              auth = msg.result.cortexToken;
              bciLib.queryHeadsets(node);
              break;

            case "createSession": 
              sessionID = msg.result.id;
              node.context().global.set("sessionID", sessionID);

              var streamArr = [];

              if (!!streamArr)
                node.context().global.set("streamArr", streamArr);
              if (!!headsetID)
                node.context().global.set("headsetID", headsetID);
              if (!!sessionID && !!headsetID) {
                storeSocketToFlow(auth);
                // Unload profile
                bciLib.getCurrentProfile(node, auth, headsetID);
              } else {
                node.error("Invalid Session Creation!");
                throw new Error("Invalid Session Creation!");
              }
              break;

            case "getCurrentProfile": 
              if (msg.result != null && msg.result != "") {
                // Use the loading profile without loading again
                var loadedProfile = msg.result;
                bciLib.unloadProfile(node, auth, headsetID, loadedProfile);
              }
              break;



            case "connectHeadset": 
              bciLib.createSession(node, auth, headsetID);
              break;

            case "queryHeadsets": 
              if (!!msg.result[0]) {
                var motionLength = msg.result[0].motionSensors.length;
                // Not all headset have 9 motion metrics
                // console.log(msg.result[0].motionSensors); 
                if (motionLength < 9) {
                  node.context().global.set("motion", "old");
                }
                headsetID = msg.result[0].id || null;
                bciLib.connectHeadset(node, headsetID);
              } else {
                if (node.socket.readyState === WS.OPEN) {
                  node.status({
                    fill : "red",
                    shape: "ring",
                    text : "No headset is connected!"
                  });
                  setTimeout(() => {
                    bciLib.queryHeadsets(node);
                  }, 3000);
                }
              }
              break;
            default: 
              node.status({ fill: "green", shape: "ring", text: `Logged in as ${loggedInUsername}` });
              break;
          }
        }
      });

      node.socket.on("error", function(err) {
        if (!node.closing) {
          clearTimeout(node.tout);
          node.tout = setTimeout(function() {
            startconn();
          }, 3000);
        }
      });
    }

    function storeSocketToFlow(auth) {
      node.status({ fill: "green", shape: "ring", text: "Connected!" });
      node.send({ payload: [auth] });
    }

    node.closing = false;
    startconn(); // start outbound connection

    node.on("close", function() {
      node.closing = true;
      sessionID    = null;
      node.socket.close();
      if (node.tout) {
        clearTimeout(node.tout);
      }
    });
  }
  RED.nodes.registerType("EMOTIV", WebSocketInNode);
};
