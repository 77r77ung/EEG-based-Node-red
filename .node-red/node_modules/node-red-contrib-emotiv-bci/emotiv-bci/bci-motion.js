// Require authentication token from bci-login node
// connect to headset (via Emotiv Universal Dongle) then
// output motion data

module.exports = function(RED) {
  "use strict";
  var bciLib = require("./bci-lib");
  var config = require("./bci-config");

  function MotionNode(n) {
    RED.nodes.createNode(this, n);

    var node   = this;
    var metric = parseInt(n.metric, 10);
    var auth   = "";
    var stream = config.stream;

    var motionName = [
      "Gyroscope, X axis",
      "Gyroscope, Y axis",
      "Gyroscope, Z axis",
      "Acceleration, X axis",
      "Acceleration, Y axis",
      "Acceleration, Z axis",
      "Magnetometer, X axis",
      "Magnetometer, Y axis",
      "Magnetometer, Z axis"
    ];

    function startconn() {
      // Connect to remote endpoint
      node.tout   = null;
      node.socket = node.context().global.get("socket");
      handleConnection();
    }

    function handleConnection() {
      node.socket.on("open", function() {
        // create a cortex session
        node.status({
          fill : "white",
          shape: "ring",
          text : "Connecting ..."
        });
      });

      node.socket.on("close", function() {
        node.status({
          fill : "red",
          shape: "ring",
          text : 
            "Please ensure that you have Cortex installed and running in the background."
        });
        if (!node.closing) {
          clearTimeout(node.tout);
          node.tout = setTimeout(function() {
            startconn();
          }, 3000);
        }
      });

      node.socket.on("message", function(data) {
        var msg = JSON.parse(data);
        if (!!msg.id && !!msg.error) {
        } else {
          if (!!msg.mot) {
            var outputMotionArr = new Array(9).fill(0);
            var cortexMotionArr  = msg.mot.slice(2, msg.mot.length); // Remove "COUNTER_MEMS","INTERPOLATED_MEMS".
            outputMotionArr = [...cortexMotionArr, ...outputMotionArr].slice(0, 9);
            var motionChan = outputMotionArr[metric];
            storeSocketToFlow(motionChan);
          }
          switch (msg.id) {
            case "subscribe":
              var outText = "";
              if (node.context().global.get("motion") === "old") {
                // Other motion metrics are not available, output will be 0.
                outText = "Getting " + motionName[metric] + " data. Only GyroX and GyroY is available!";
              } else {
                outText = "Getting " + motionName[metric] + " data";
              }
              node.status({
                fill : "green",
                shape: "dot",
                text : outText
              });
              break;
          }
        }
      });
    }

    function storeSocketToFlow(msg) {
      node.send({ payload: msg });
    }

    this.on("input", function(msg) {
          auth      = msg.payload[0];
      var streamArr = node.context().global.get("streamArr") || [];
      var sessionID = node.context().global.get("sessionID");

      if (streamArr.indexOf(stream) < 0) {
        bciLib.subscribe(node, auth, stream, sessionID);
        streamArr.push(stream);
        node.context().global.set("streamArr", streamArr);
      }
    });

    node.closing = false;
    startconn(); // start outbound connection

    node.on("close", function() {
      node.closing = true;
      node.socket.close();
      if (node.tout) {
        clearTimeout(node.tout);
      }
    });
  }

  RED.nodes.registerType("Motion-Sensor", MotionNode);
};
